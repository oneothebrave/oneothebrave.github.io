## setState是同步还是异步？

setState这个函数本身只是一个普通的调用执行的函数，肯定是同步的。



所谓的同步还是异步其实就是看调用setState之后，**是否会立即触发一次组件重渲染**，而不是 state 是否“立即生效”。state 在任何场景中都不会在函数体中立刻改变。



结论：在react17及以前，在react可调度的范围内是异步的，反之同步。

Q：什么是react可调度范围内？

A：react合成事件，生命周期函数

Q：什么是react合成事件？

A：**React 的合成事件是 React 封装的一套跨浏览器的事件系统。它使用事件委托（统一绑定在根节点），并模拟了原生事件 API。 这样可以统一处理机制、提升性能，同时解决浏览器兼容性问题**，它在所有浏览器中都具有一致的行为。如onClick、onChange等由 React 包装的事件

Q: 什么是react可调度范围外？

A：宏任务(setTimeout, setInterval)， 微任务(promise), 或直接在DOM元素上绑定的原生事件



#### ✅但是，  **在react18之后，setState无论在什么情况下都是异步的！！**！



| 场景                                                        | 是否异步         | 是否自动批处理          | `state` 是否立即更新可读 | 会触发几次渲染（多次 setState）             |
| ----------------------------------------------------------- | ---------------- | ----------------------- | ------------------------ | ------------------------------------------- |
| ✅ React 合成事件（如 `onClick`）                            | ✅ 是             | ✅ 是                    | ❌ 不能立即读取（是旧的） | 1 次（多次合并）                            |
| ✅ `setTimeout` / `setInterval`                              | ✅ 是             | ✅ 是                    | ❌ 是旧的（闭包）         | 1 次（同一宏任务内） 🔁 多次 if 多个 timeout |
| ✅ `Promise.then()` / `async/await`                          | ✅ 是             | ✅ 是                    | ❌ 是旧的                 | 1 次（同一个微任务）                        |
| ✅ React 生命周期方法（`useEffect`, `componentDidMount` 等） | ✅ 是             | ✅ 是                    | ❌ 是旧的                 | 1 次                                        |
| ⚠️ 多个宏任务（多个 `setTimeout`、多个 `await`）             | ✅ 是             | ❌ 否（批处理无效）      | ❌ 是旧的                 | 多次                                        |
| ⚠️ 原生 DOM 事件（`addEventListener`）                       | ✅ 是             | ✅ 是（React 18 才支持） | ❌ 是旧的                 | 1 次（React 18） 多次（React 17）           |
| ✅ 同步函数内多次调用 `setState(fn)`                         | ✅ 是             | ✅ 是                    | ❌ 是旧的（不会中断执行） | 1 次                                        |
| ❗ 使用 `flushSync()` 包裹                                   | ❌ 否（强制同步） | ❌ 否                    | ✅ 可立即读取             | 每次都立即触发渲染                          |

从上表可以看出:

1. state的值一直都是旧值(flushSync除外)
2. setState只是触发一次更新请求，不会中断下面代码的执行或立即重渲染组件
3. 如果遇到多个setTimeOut中都有setState的情况，React会在每个setState执行之后 继续执行后续 JS（无中断），并“安排”一次重渲染，渲染完成之后继续下一次重渲染...



什么是自动批处理？

多个 `setState` 在一次任务（事件、微任务、effect 等）中执行时，**React 会合并这些状态更新，只触发一次渲染**。

- `React 17` 只在合成事件 & 生命周期中支持
- `React 18` 在大多数异步场景中都自动支持（Promise、setTimeout、原生事件等）



> 在 React 18 中，`setState` 在所有场景（包括原生事件、setTimeout、Promise 等）都是异步的，并且大多数情况下都支持自动批处理，只会在**跨多个宏任务时才拆分成多次渲染**。





## useMemo和useCallback的区别

| 对比维度     | useMemo                                    | useCallback                                   |
| ------------ | ------------------------------------------ | --------------------------------------------- |
| 作用         | 缓存**计算结果**                           | 缓存**函数引用**                              |
| 返回值       | 某个**值（可能是对象、数组、数字）**       | 一个**函数**                                  |
| 用于         | 避免**重复计算**                           | 避免**函数地址变化导致子组件重新渲染**        |
| 依赖变化时   | 重新执行函数，返回新值                     | 返回一个新函数（闭包）                        |
| 常见配合使用 | 用在依赖复杂对象的组件中（props、context） | 搭配 `React.memo` 优化子组件 props 传入的函数 |



总结：`useMemo` 是用来缓存复杂**计算的结果**，避免在每次渲染时都重新计算；`useCallback` 则是用来**缓存函数的引用**，避免因为函数地址变了导致子组件不必要的更新。



| 错误说法                 | 为什么错                                                     |
| ------------------------ | ------------------------------------------------------------ |
| `useCallback` 能提升性能 | ❌ 不一定，**频繁创建函数并不一定有性能问题**，加了还可能占内存 |
| `useMemo` 能避免组件渲染 | ❌ 它只避免了值重复计算，不能阻止组件本身的 render            |



## 什么是虚拟DOM，为什么使用虚拟DOM？

React中的虚拟DOM是React内部用的JS对象树，用于描述UI状态。当首次渲染React组件时，就会创建一个虚拟DOM树，当组件的状态发生变化时，React会创建一个新的虚拟DOM树，然后将新的树与之前的树进行对比，用找到差异来更新实际DOM的部分。这样只修改真正变化的部分，提高性能，将多个更新批处理，还能减少重渲染的次数。缺点：在非常具体、高度优化的场景中，它的性能可能不如手动 DOM 操作

