import{o as l,c as e,d as n,e as u}from"./app.ea498c01.js";const s='{"title":"介绍","description":"","frontmatter":{},"headers":[{"level":2,"title":"介绍","slug":"介绍"},{"level":2,"title":"Promise语法","slug":"promise语法"},{"level":2,"title":"（宏）任务队列和微任务队列","slug":"（宏）任务队列和微任务队列"},{"level":2,"title":"Async / Await","slug":"async-await"}],"relativePath":"translation/devto-promises-async-await.md","lastUpdated":1622735471948}',t={},i=n("div",{class:"tip custom-block"},[n("p",{class:"custom-block-title"},"TIP"),n("p",null,[u("本篇文章是怀着赞许与尊敬从"),n("a",{href:"https://dev.to/lydiahallie",target:"_blank",rel:"noopener noreferrer"},"Lydia Hallie"),u("的文章中翻译而来的，"),n("a",{href:"https://dev.to/lydiahallie/javascript-visualized-promises-async-await-5gke",target:"_blank",rel:"noopener noreferrer"},"原文"),u("写的实在是太性感了")])],-1),o=n("p",null,[u("你是否有过这样的经历，跑一段JS代码，但它就是不按你预期地运行？看起来就像是一些函数被随机地，在不可预测的时间被执行了，或者执行被延迟了。那你可能正在与ES6引入的新特性打交道："),n("strong",null,"Promise"),u(" . 中文译名：期约")],-1),r=n("p",null,"Promise是什么？为什么要用它？它到底是怎么工作的？如何使用它?",-1),a=n("p",null,[u("往下看之前最好先看看"),n("a",{href:"/translation/devto-jseventloop.html"},[n("em",null,"事件循环")]),u(" 的原理. 如果你还没看过.")],-1),m=n("h2",{id:"介绍"},[n("a",{class:"header-anchor",href:"#介绍","aria-hidden":"true"},"#"),u(" 介绍")],-1),c=n("p",null,"在编写JavaScript时，我们经常不得不处理依赖于其他任务的任务！假设我们想要获取一张图像，对其进行压缩，应用过滤器，然后将其保存。",-1),p=n("p",null,[u("我们需要做的第一件事，就是获取我们想要编辑的图像。"),n("em",null,"getImage"),u(" 函数可以解决这个问题！只有在成功加载该图像之后，我们才能将该值传递给 "),n("em",null,"resizeImage"),u(" 函数。当图像成功调整大小时，我们希望在 "),n("em",null,"applyFilter"),u(" 函数中对图像应用过滤器。在压缩图像并添加筛选器后，我们希望保存图像并让用户知道一切工作正常！")],-1),d=n("p",null,"最后，我们会得到这样的结果：",-1),A=n("p",null,[n("img",{src:"/assets/PAA-1.6a595c51.png",alt:"PAA-1"})],-1),P=n("p",null,"虽然这么做也可以，但我们最终得到了许多嵌套的回调函数，它们依赖于前面的回调函数，这简直是回调地狱，这样的代码很难懂也很难维护。",-1),g=n("p",null,"幸运的是，现在我们有了Promise，让我们来看看什么是Promiss，以及它在这样的情况下可以如何帮助我们！",-1),h=n("h2",{id:"promise语法"},[n("a",{class:"header-anchor",href:"#promise语法","aria-hidden":"true"},"#"),u(" Promise语法")],-1),f=n("p",null,[u("我们可以使用一个接受回调函数的 "),n("em",null,"Promise构造函数"),u(" 来创建 "),n("em",null,"Promise"),u(" :")],-1),v=n("p",null,[n("img",{src:"/assets/PAA-2.2000007a.gif",alt:"PAA-2"})],-1),y=n("p",null,"等等，这是返回了个什么玩意儿？",-1),b=n("p",null,[n("em",null,[n("strong",null,"Promise")]),u(" 是一个对象，包含着一个 "),n("strong",null,"status"),u("([[PromiseStatus]]) 属性和一个 "),n("strong",null,"value"),u("([[PromiseValue]])属性。从上面的动图中你可以看见 "),n("em",null,"[[PromiseStatus]]"),u(' 的值为 "pending"，'),n("em",null,"Promise"),u(" 的值为 "),n("em",null,"undefined"),u(" .")],-1),j=n("p",null,"别担心--你不永远不必与此对象交互，甚至不能访问[[PromiseStatus]]和[[PromiseValue]]属性！但是，在使用Promises时，这些属性的值很重要。",-1),k=n("div",{class:"tip custom-block"},[n("p",{class:"custom-block-title"},"TIP"),n("p",null,"译者注：期约的状态是私有的，不能直接通过 JavaScript 检测到。这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。另外，期约的状态也不能被外部 JavaScript 代码修改。这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码")],-1),T=n("p",null,[n("em",null,"Promise"),u(" 的状态[[PromiseStatus]]有以下三种：")],-1),w=n("ul",null,[n("li",null,[u("⏳ "),n("em",null,"pending"),u(" : promise既没有被兑现(fulfilled)，也没有被拒绝(rejected) , promise依旧悬而未决")]),n("li",null,[u("✅ "),n("em",null,"fulfilled"),u(" ：promise已经被兑现(fulfilled)，一切都很顺利，没有发生任何错误")]),n("li",null,[u("❌ "),n("em",null,"rejected"),u(" : promise已经被拒绝(rejected), 什么事情出错了")])],-1),I=n("blockquote",null,[n("p",null,"译者举例子：想象你叫了一辆滴滴，把从平台接单到司机把你送到目的地当做一个Promise,就是你和平台立下一个期约，约定在那个时间段内，平台派车把你送到目的地。"),n("p",null,[u("在你下单后，直到你被送到目的地前，这个状态都一直是 "),n("em",null,"pending"),u('， 因为你还没有到目的地(promise还没有被兑现)，你也没有"到不了目的地"(promise还没有出错)')]),n("p",null,"然后接下来会出现两种情况："),n("ol",null,[n("li",null,[n("p",null,"你被安全地送到了目的地，promise被兑现，状态改成fulfilled")]),n("li",null,[n("p",null,"司机接到电话，说他老婆突然要生孩子了，司机作为一个好男人，决定要去医院，不去接你了，取消了订单。"),n("p",null,"或者司机突然发现他没老婆，但是他开的是某度造的车，半路给你带到莆田系医院去了等等等等，总之就是出现问题了，那么promise的状态就成了rejected，因为promise没有被完成。")])])],-1),S=n("p",null,[u("在上面的例子中，我们只是简单地传了一个回调函数 "),n("code",null,"() => {}"),u(" 给 "),n("em",null,"Promise"),u(" 构造器。然而，这个回调函数实际上接受两个参数：第一个参数常常被称作 "),n("code",null,"resolve"),u(" 或者 "),n("code",null,"res"),u(" , 是当 "),n("em",null,"Promise"),u(" 的状态应当改为 "),n("em",null,"fulfilled"),u(" 时触发。第二个参数常常被称作 "),n("code",null,"reject"),u(" 或者 "),n("code",null,"rej"),u(" , 是当 "),n("em",null,"Promise"),u(" 的状态应当改为 "),n("em",null,"reject"),u(" 时触发，表示有什么东西出错了")],-1),x=n("p",null,[n("img",{src:"/assets/PAA-3.b69afe1e.png",alt:"PAA-3"})],-1),J=n("p",null,[u("让我看看调用 "),n("code",null,"resolve"),u(" 或者"),n("code",null,"reject"),u(" 方法时会输出什么：")],-1),F=n("p",null,[n("img",{src:"/assets/PAA-4.fcb7f00c.gif",alt:"PAA-4"})],-1),q=n("p",null,[u("不错！我们终于知道如何摆脱 "),n("em",null,"pending"),u(" 状态和 "),n("em",null,"undefined"),u(" 值！如果我们调用了 "),n("code",null,"res"),u(" 函数，那么 "),n("em",null,"promise"),u(' 的状态就是 "fulfilled"，如果我们调用了'),n("code",null,"rej"),u(" 函数，那么 "),n("em",null,"promise"),u(' 的状态就是"rejected"。而'),n("em",null,"promise"),u(" 的值，既[[PromiseValue]]的值，就是我们传给 "),n("code",null,"res"),u(" 或者"),n("code",null,"rej"),u("的值。")],-1),E=n("p",null,[u("好了，现在我们对如何控制那个模糊的 "),n("em",null,"Promise"),u(" 对象有了更多的了解。但是它是用来做什么的呢？")],-1),z=n("p",null,"在介绍部分中，我展示了一个示例，在该示例中，我们获取图像、压缩它、应用过滤器，并保存它！最终，这变成了一个疯狂嵌套回调的乱七八糟的局面。",-1),V=n("p",null,[u("幸运的是，"),n("em",null,"Promise"),u(" 可以帮助我们解决这个问题！首先，让我们重写整个代码块，以便每个函数返回一个 "),n("em",null,"Promise"),u("。")],-1),W=n("p",null,[u("如果图像已加载，并且一切正常，那就调用"),n("code",null,"res"),u("来处理promise吧！否则，如果在加载文件时出现错误，那就调用"),n("code",null,"rej"),u("来处理promise吧."),n("img",{src:"/assets/PAA-5.a76b88f6.png",alt:"PAA-5"})],-1),_=n("p",null,"让我们看看当我们在终端中运行这段代码时会发生什么！",-1),M=n("p",null,[n("img",{src:"/assets/PAA-6.6233244a.gif",alt:"PAA-6"})],-1),B=n("p",null,"棒！正如我们预期的那样，返回了一个promise，其中包含已解析数据的值。",-1),H=n("p",null,"然后呢？我们不关心整个Promise对象，我们只关心数据的值！幸运的是，有一些内置的方法可以获得promise的值。对于promise，我们可以附加3种方法：",-1),L=n("ul",null,[n("li",null,[n("code",null,".then()"),u(": 在promise执行"),n("code",null,"resolve"),u("之后被执行")]),n("li",null,[n("code",null,".catch()"),u(": 在promise执行"),n("code",null,"reject"),u("之后被执行")]),n("li",null,[n("code",null,".finally()"),u(": 无论promise执行"),n("code",null,"resolve"),u("或者是"),n("code",null,"reject"),u("，都会被执行")])],-1),U=n("p",null,[n("img",{src:"/assets/PAA-7.9264584f.png",alt:"PAA-7"})],-1),C=n("p",null,[n("code",null,".then"),u("方法接受传递给"),n("code",null,"resolve"),u("方法的值")],-1),D=n("p",null,[n("img",{src:"/assets/PAA-8.dd090a85.gif",alt:"PAA-8"})],-1),G=n("p",null,[n("code",null,".catch"),u("方法接受传递给"),n("code",null,"reject"),u("方法的值")],-1),K=n("p",null,[n("img",{src:"/assets/PAA-9.33654568.gif",alt:"PAA-9"})],-1),N=n("p",null,"终于，我们得到了在没有整个Promise对象的情况下由Promise生成的值！我们现在可以用这个值做任何我们想做的事情。",-1),O=n("hr",null,null,-1),Q=n("p",null,[u("仅供参考，当您知道promise将始终"),n("code",null,"resolve"),u("或始终"),n("code",null,"reject"),u("时，您可以使用要reject或resolve promise的值编写Promise.resolve或Promise.reject！（翻译不明白，太难翻译了，还是看图吧）")],-1),R=n("p",null,[n("img",{src:"/assets/PAA-10.3f78495f.png",alt:"PAA-10"})],-1),X=n("p",null,"接下来你会经常看到这种语法",-1),Y=n("hr",null,null,-1),Z=n("p",null,[u("在"),n("em",null,"getImage"),u("示例中，我们最终不得不嵌套多个回调才能运行它们。幸运的是，"),n("code",null,".then"),u(" 处理程序可以帮助我们！")],-1),$=n("p",null,[n("code",null,".then"),u(" 方法本身的返回值也是一个promise值(注意是返回值哦，传给 "),n("em",null,".then"),u(" 的是promise 的value，不是promise)，这意味着我们可以链接任意多个"),n("code",null,".then"),u("：前一个"),n("em",null,"then"),u("回调的结果将作为参数传递给下一个"),n("em",null,"then"),u("回调！")],-1),ll=n("p",null,[n("img",{src:"/assets/PAA-11.88e20a41.png",alt:"PAA-11"})],-1),el=n("p",null,[u("在"),n("em",null,"getImage"),u("示例中，我们可以链接多个"),n("em",null,"then"),u("回调，以便将处理后的图像传递给下一个函数！我们得到的不是许多嵌套的回调，而是一个干净的"),n("em",null,"then"),u("链。")],-1),nl=n("p",null,[n("img",{src:"/assets/PAA-12.d9425e7d.png",alt:"PAA-12"})],-1),ul=n("p",null,"完美！这个写法可比之前的好多了",-1),sl=n("hr",null,null,-1),tl=n("h2",{id:"（宏）任务队列和微任务队列"},[n("a",{class:"header-anchor",href:"#（宏）任务队列和微任务队列","aria-hidden":"true"},"#"),u(" （宏）任务队列和微任务队列")],-1),il=n("p",null,[u("现在我们对如何创造 "),n("em",null,"promise"),u(" 以及如何从 "),n("em",null,"promise"),u(" 中提取值有了更多的了解。让我们再向脚本中添加一些代码，然后再次运行它：")],-1),ol=n("p",null,[n("img",{src:"/assets/PAA-13.8f026eed.gif",alt:"PAA-13"})],-1),rl=n("p",null,"等等，发生了什么！🤯",-1),al=n("p",null,'首先，“Start!” 被打印出来，这个没问题。然而第二个被打印出来的值居然是 "End!" ，而不是promise的resolve的值，"Promise!" 最后才被打印出来，发生了什么？',-1),ml=n("p",null,[u("我们终于看到了 "),n("em",null,"promise"),u(" 的真正力量！虽然JavaScript是单线程的，但我们可以使用 "),n("em",null,"promise"),u(" 添加异步行为！")],-1),cl=n("hr",null,null,-1),pl=n("p",null,[u("等一下，我"),n("a",{href:"/translation/devto-jseventloop.html"},"事件循环"),u("呢?难道我们不能使用浏览器原生的方法(如setTimeout)来创建某种异步行为吗？")],-1),dl=n("p",null,[u("当然可以！不过，在事件循环中，其实有两种类型的队列："),n("strong",null,"（宏）任务队列"),u(" 和 "),n("strong",null,"微任务队列"),u("，（宏）任务队列用于（宏）任务，微任务队列用于微任务。")],-1),Al=n("p",null,"那么什么是（宏）任务，什么又是微任务呢？常见的如下表所示，包括但不限于",-1),Pl=n("table",null,[n("thead",null,[n("tr",null,[n("th",{style:{"text-align":"center"}},"种类"),n("th",{style:{"text-align":"center"}},"任务")])]),n("tbody",null,[n("tr",null,[n("td",{style:{"text-align":"center"}},"(宏）任务"),n("td",{style:{"text-align":"center"}},[u("setTimeout"),n("code",null,"|"),u("setInterval"),n("code",null,"|"),u("setImmediate")])]),n("tr",null,[n("td",{style:{"text-align":"center"}},"微任务"),n("td",{style:{"text-align":"center"}},[u("Promise callback"),n("code",null,"|"),u("process.nextTick"),n("code",null,"|"),u("queueMicrotask")])])])],-1),gl=n("p",null,[u("啊，我们在微任务列表中看到了Promise！当Promise调用其"),n("code",null,"then()"),u("、"),n("code",null,"catch()"),u("或"),n("code",null,"finally()"),u("方法时，方法中的回调被添加到微任务队列中！这意味着"),n("code",null,"then()"),u("、"),n("code",null,"catch()"),u("或"),n("code",null,"finally()"),u("方法中的回调不会立即执行，实质上是向我们的JavaScript代码添加了一些异步行为！")],-1),hl=n("p",null,[u("那么"),n("code",null,"then()"),u("、"),n("code",null,"catch()"),u("或"),n("code",null,"finally()"),u("方法中的回调函数是什么时候执行的呢？事件循环为任务赋予不同的优先级：")],-1),fl=n("ol",null,[n("li",null,"执行当前在调用堆栈中的所有函数。当它们返回值时，它们会从堆栈中弹出。"),n("li",null,"当调用堆栈为空时，所有排队的微任务将逐个弹出到调用堆栈上，并被执行！(微任务本身也可以返回新的微任务，有效地创建了一个无限的微任务循环)"),n("li",null,"如果调用堆栈和微任务队列都为空，事件循环就会检查(宏)任务队列上是否有剩余的任务。然后（宏）任务被弹出到调用堆栈上，执行，然后弹出！")],-1),vl=n("hr",null,null,-1),yl=n("p",null,"让我们快速来看一个简单的例子：",-1),bl=n("ul",null,[n("li",null,[n("em",null,"Task1"),u(" : 一个立即添加到调用堆栈中的函数。在我们的代码中可以立即调用它。")]),n("li",null,[n("em",null,"Task2, Task3, Task4"),u(" ：微任务们。例如，一个promise的"),n("code",null,"then"),u("回调函数，或者使用 "),n("em",null,"queneMicrotask"),u(" 添加的任务")]),n("li",null,[n("em",null,"Task5， Task6"),u(" : 一个(宏)任务队列, 例如，"),n("em",null,"setTimeout"),u(" 和 "),n("em",null,"setImmediate"),u(" 的回调函数")])],-1),jl=n("p",null,[n("img",{src:"/assets/PAA-15.9466d8aa.gif",alt:"PAA-15"})],-1),kl=n("p",null,[u("首先，"),n("em",null,"Task1"),u("返回一个值，并从调用堆栈中弹出。然后，引擎检查微任务队列中排队的任务。一旦所有任务都被放入调用堆栈并最终弹出，引擎就会检查(宏)任务队列中的任务，这些任务被推到调用堆栈上，并在它们返回值时被弹出。")],-1),Tl=n("p",null,[u("也就是说，事件执行的优先级顺序为："),n("strong",null,"同步函数 > 微任务(不进入Web API) > (宏)任务")],-1),wl=n("p",null,"现在我们用一些真正的代码来使用它！",-1),Il=n("p",null,[n("img",{src:"/assets/PAA-16.f184c847.png",alt:"PAA-16"})],-1),Sl=n("p",null,[u("在这段代码中，我们有宏任务"),n("em",null,"setTimeout"),u("和微任务Promise *then()*回调。一旦引擎到达setTimeout函数行。让我们一步一步地运行这段代码，看看记录了什么！")],-1),xl=n("p",null,"在第一行，引擎遇到console.log()方法。它被添加到调用堆栈，之后打印出值*start！*到控制台。该方法从调用堆栈中弹出，引擎继续。",-1),Jl=n("p",null,[n("img",{src:"/assets/PAA-17.c21ce906.gif",alt:"PAA-17"})],-1),Fl=n("p",null,[u("接着引擎遇到"),n("em",null,"setTimeout"),u("方法，该方法被推到调用堆栈。"),n("em",null,"setTimeout"),u("方法是浏览器原生的：它的回调函数"),n("code",null,"()=>console.log(‘in timeout’)"),u("将被添加到Web API(此时"),n("em",null,"setTimeout"),u("已经返回了值，被弹出堆栈)，直到计时器结束。尽管我们为计时器提供了值0，但是回调仍然首先被推送到Web API，然后被添加到(宏)任务队列："),n("em",null,"setTimeout"),u("是一个宏任务！")],-1),ql=n("p",null,[n("img",{src:"/assets/PAA-18.16de7c62.gif",alt:"PAA-18"})],-1),El=n("p",null,[u("继续，引擎遇到*Promise.resolve()*方法。*Promise.resolve()*方法被添加到调用堆栈中，after which is resolves with the value "),n("code",null,"Promise!"),u(". Its "),n("code",null,"then"),u(" callback function gets added to the "),n("strong",null,"microtask queue"),u(".（翻译不来，自己理解）")],-1),zl=n("p",null,[n("img",{src:"/assets/PAA-19.ca019b19.gif",alt:"PAA-19"})],-1),Vl=n("p",null,"往下，引擎遇到console.log()方法。它会立即添加到调用堆栈中，然后打印出值*End！*到控制台，从调用堆栈中弹出，引擎继续。",-1),Wl=n("p",null,[n("img",{src:"/assets/PAA-20.f3e1fe88.gif",alt:"PAA-20"})],-1),_l=n("p",null,[u("紧接着，引擎发现调用堆栈现在为空。由于调用堆栈为空，它将检查微任务队列中是否有排队的任务！是的，确实有，promise的 "),n("em",null,"then"),u(" 回调函数已经迫不及待了！它被推入进调用堆栈中，然后输出Promise的resolved的值：在本例中是字符串"),n("code",null,"Promise！")],-1),Ml=n("p",null,[n("img",{src:"/assets/PAA-21.e56ca9bc.gif",alt:"PAA-21"})],-1),Bl=n("p",null,"引擎发现调用堆栈为空，因此它将再次检查微任务队列，以查看是否还有任务在排队。不，微任务队列都是空的。",-1),Hl=n("p",null,[u("现在是检查(宏)任务队列的时候了："),n("em",null,"setTimeout"),u("回调仍在那里等待！"),n("em",null,"setTimeout"),u("回调被推入进调用堆栈。回调函数返回"),n("em",null,"console.log"),u("方法，该方法记录字符串"),n("code",null,"“In Timeout！”"),u("。"),n("em",null,"setTimeout"),u("回调从调用堆栈中弹出。")],-1),Ll=n("p",null,[n("img",{src:"/assets/PAA-22.0bbbd787.gif",alt:"PAA-22"})],-1),Ul=n("p",null,"终于完成了！看起来也就那么亿点点复杂嘛.",-1),Cl=n("hr",null,null,-1),Dl=n("h2",{id:"async-await"},[n("a",{class:"header-anchor",href:"#async-await","aria-hidden":"true"},"#"),u(" Async / Await")],-1),Gl=n("p",null,[u("ES7引入了一种新的方式来在JavaScript中添加异步行为，并使得使用 "),n("em",null,"Promise"),u(" 变得更容易！通过引入"),n("em",null,"async"),u("和"),n("em",null,"await"),u("关键字，我们可以创建隐式返回承诺的异步函数。但是我们怎么能做到这一点呢？。")],-1),Kl=n("p",null,[u("在前面，我们看到可以使用"),n("em",null,"Promise"),u("对象显式创建承诺，无论是通过键入"),n("code",null,"new Promise(()=>{})"),u("、"),n("em",null,"Promise.resolve"),u("还是"),n("em",null,"Promise.reject"),u("。")],-1),Nl=n("p",null,[u("我们现在可以创建隐式返回对象的异步函数，而不是显式使用"),n("em",null,"Promise"),u("对象！这意味着我们不再需要自己编写任何"),n("em",null,"Promise"),u("对象。")],-1),Ol=n("p",null,[n("img",{src:"/assets/PAA-23.a1c05a9f.png",alt:"PAA-23"})],-1),Ql=n("p",null,[u("尽管 "),n("em",null,"async"),u(" 函数隐式返回 "),n("em",null,"promises"),u(" 的事实不可置否，但在使用"),n("em",null,"await"),u("关键字时，才可以看到"),n("em",null,"async"),u("函数的真正威力！使用"),n("em",null,"await"),u("关键字，我们可以挂起异步函数，同时等待被 "),n("em",null,"await"),u(" 的值返回已解析的承诺。如果我们想要获得这个已解析承诺的值，就像我们之前对*then()*回调所做的那样，我们可以将变量赋给等待的承诺值！")],-1),Rl=n("p",null,"所以，我们可以暂停异步功能？好的，很好，但是..这到底是什么意思？",-1),Xl=n("p",null,"让我们看看当我们运行以下代码块时会发生什么：",-1),Yl=n("p",null,[n("img",{src:"/assets/PAA-24.42188dbe.gif",alt:"PAA-24"})],-1),Zl=n("p",null,"发生了什么？",-1),$l=n("p",null,[n("img",{src:"/assets/PAA-25.ab7dc59e.gif",alt:"PAA-25"})],-1),le=n("p",null,[u("首先，引擎遇到一个"),n("code",null,"console.log"),u("。它被推入到调用堆栈上，打印出 "),n("em",null,"Before function"),u("。")],-1),ee=n("p",null,[n("img",{src:"/assets/PAA-26.f6562e94.gif",alt:"PAA-26"})],-1),ne=n("p",null,[u("然后，我们调用异步函数"),n("code",null,"myFunc()"),u("，然后运行"),n("em",null,"myFunc"),u("的函数体。在函数体的第一行，我们调用另一个"),n("code",null,"console.log"),u("，打印出"),n("code",null,"In function!")],-1),ue=n("hr",null,null,-1),se=n("p",null,[n("img",{src:"/assets/PAA-27.f6e2ad0c.gif",alt:"PAA-27"})],-1),te=n("p",null,[u("函数体继续被执行，这将我们带到第二行。最后，我们看到一个"),n("em",null,"await"),u("关键字！。")],-1),ie=n("p",null,[u("在这里发生的第一件事是执行"),n("em",null,"await"),u("后的值：在这里是 "),n("em",null,"one"),u(" 函数。它被推入到调用堆栈上，并最终返回一个已解析的承诺。一旦承诺被解析并且 "),n("em",null,"one"),u(" 函数返回了值，引擎就会遇到"),n("em",null,"await"),u("关键字。"),n("strong",null,"注意是先执行紧跟在await后的表达式然后再挂起async函数"),u("。")],-1),oe=n("p",null,[u("当遇到"),n("em",null,"await"),u("关键字时，"),n("em",null,"async"),u("函数被挂起。函数体的执行暂停，"),n("em",null,"async"),u("函数的其余部分在微任务中运行，而不是在常规任务中运行！")],-1),re=n("hr",null,null,-1),ae=n("p",null,[n("img",{src:"/assets/PAA-28.01e9aed0.gif",alt:"PAA-27"})],-1),me=n("p",null,[u("现在"),n("em",null,"async"),u("函数"),n("em",null,"myFunc"),u("由于遇到"),n("em",null,"await"),u("关键字而挂起，引擎跳出异步函数并继续在调用异步函数的执行上下文中执行代码：在本例中是全局执行上下文！")],-1),ce=n("hr",null,null,-1),pe=n("p",null,[n("img",{src:"/assets/PAA-29.845c7ad7.gif",alt:"PAA-29"})],-1),de=n("p",null,[u("最后，已经没有任务需要在在全局执行上下文中运行！事件循环检查是否有任何微任务在排队：确实有！异步"),n("em",null,"myFunc"),u("函数在解析"),n("em",null,"one"),u("的值后排队。"),n("em",null,"myFunc"),u("推入调用堆栈，并在之前停止的地方继续运行。")],-1),Ae=n("p",null,[u("变量"),n("em",null,"res"),u("最终获得它的值，即promise的"),n("code",null,"resolve"),u("的值！我们调用"),n("code",null,"console.log"),u("打印出"),n("em",null,"res"),u("的值：字符串"),n("code",null,"one!"),u("并从调用堆栈中弹出！。")],-1),Pe=n("p",null,[u("终于，一切都完成了！你有没有注意到，与"),n("em",null,"promise"),u("相比，"),n("em",null,"async"),u("功能有何不同？"),n("em",null,"await"),u("关键字挂起异步函数，而如果我们当时使用了Promise的"),n("code",null,".then()"),u("，那么Promise将继续执行！")],-1),ge=n("blockquote",null,[n("p",null,[u("翻译到后面感觉翻译地乱七八糟的。阅读原文移步"),n("a",{href:"https://dev.to/lydiahallie/javascript-visualized-promises-async-await-5gke",target:"_blank",rel:"noopener noreferrer"},"这里")])],-1);t.render=function(n,u,s,t,he,fe){return l(),e("div",null,[i,o,r,a,m,c,p,d,A,P,g,h,f,v,y,b,j,k,T,w,I,S,x,J,F,q,E,z,V,W,_,M,B,H,L,U,C,D,G,K,N,O,Q,R,X,Y,Z,$,ll,el,nl,ul,sl,tl,il,ol,rl,al,ml,cl,pl,dl,Al,Pl,gl,hl,fl,vl,yl,bl,jl,kl,Tl,wl,Il,Sl,xl,Jl,Fl,ql,El,zl,Vl,Wl,_l,Ml,Bl,Hl,Ll,Ul,Cl,Dl,Gl,Kl,Nl,Ol,Ql,Rl,Xl,Yl,Zl,$l,le,ee,ne,ue,se,te,ie,oe,re,ae,me,ce,pe,de,Ae,Pe,ge])};export default t;export{s as __pageData};
