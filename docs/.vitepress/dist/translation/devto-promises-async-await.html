<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>
      介绍 | Oneo's Blog
    </title>
    <meta name="description" content="Oneo Sanchez's Tech Blog">
    <link rel="stylesheet" href="/assets/style.56d02f33.css">
    <link rel="modulepreload" href="/assets/Home.5c1bd09a.js">
    <link rel="modulepreload" href="/assets/app.2a123ea2.js">
    <link rel="modulepreload" href="/assets/translation_devto-promises-async-await.md.b30fd95a.lean.js">
    <link rel="modulepreload" href="/assets/app.2a123ea2.js">
    
    
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-6e7c0b86><div class="sidebar-button" data-v-6e7c0b86><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="Oneo&#39;s Blog, back to home" data-v-6e7c0b86 data-v-76c79d52><!----> Oneo&#39;s Blog</a><div class="flex-grow" data-v-6e7c0b86></div><div class="nav" data-v-6e7c0b86><nav class="nav-links" data-v-6e7c0b86 data-v-f465d38e><!--[--><div class="item" data-v-f465d38e><div class="nav-link" data-v-f465d38e data-v-99f6c566><a class="item" href="/" data-v-99f6c566>Home <!----></a></div></div><div class="item" data-v-f465d38e><div class="nav-link" data-v-f465d38e data-v-99f6c566><a class="item isExternal" href="https://github.com/oneothebrave/oneothebrave.github.io" target="_blank" rel="noopener noreferrer" data-v-99f6c566>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-99f6c566><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-58e261f2><nav class="nav-links nav" data-v-58e261f2 data-v-f465d38e><!--[--><div class="item" data-v-f465d38e><div class="nav-link" data-v-f465d38e data-v-99f6c566><a class="item" href="/" data-v-99f6c566>Home <!----></a></div></div><div class="item" data-v-f465d38e><div class="nav-link" data-v-f465d38e data-v-99f6c566><a class="item isExternal" href="https://github.com/oneothebrave/oneothebrave.github.io" target="_blank" rel="noopener noreferrer" data-v-99f6c566>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-99f6c566><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-58e261f2><!--[--><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><p class="sidebar-link-item" data-v-58e261f2>JS笔记</p><ul class="sidebar-links" data-v-58e261f2><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/JsNote/1" data-v-58e261f2>一.什么是JavaScript</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/JsNote/2" data-v-58e261f2>二.HTML中的JavaScript</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/JsNote/3" data-v-58e261f2>三.语言基础</a><!----></li></ul></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><p class="sidebar-link-item" data-v-58e261f2>VitePress搭建博客并部署到GitHub Pages</p><ul class="sidebar-links" data-v-58e261f2><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/vitepress-blog-setup" data-v-58e261f2>搭建</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/vitepress-blog-depoly" data-v-58e261f2>部署</a><!----></li></ul></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><p class="sidebar-link-item" data-v-58e261f2>[exports与module.exports],[export与export default],[import与require]</p><ul class="sidebar-links" data-v-58e261f2><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/export-import" data-v-58e261f2>总结</a><!----></li></ul></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><p class="sidebar-link-item" data-v-58e261f2>TypeScript教程</p><ul class="sidebar-links" data-v-58e261f2><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/TypeScript" data-v-58e261f2>总结</a><!----></li></ul></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><p class="sidebar-link-item" data-v-58e261f2>翻译而来</p><ul class="sidebar-links" data-v-58e261f2><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="/translation/devto-jseventloop" data-v-58e261f2>JavaScript中的事件循环</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item active" href="/translation/devto-promises-async-await" data-v-58e261f2>JS中的Promise,async和await</a><ul class="sidebar-links" data-v-58e261f2><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="#介绍" data-v-58e261f2>介绍</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="#promise语法" data-v-58e261f2>Promise语法</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="#（宏）任务队列和微任务队列" data-v-58e261f2>（宏）任务队列和微任务队列</a><!----></li><li class="sidebar-link" data-v-58e261f2 data-v-58e261f2><a class="sidebar-link-item" href="#async-await" data-v-58e261f2>Async / Await</a><!----></li></ul></li></ul></li><!--]--></ul><!--[--><!--]--></aside><!-- TODO: make this button accessible --><div class="sidebar-mask"></div><main class="page" data-v-d36a7fda><div class="container" data-v-d36a7fda><!--[--><!--]--><div class="content" data-v-d36a7fda><div data-v-d36a7fda><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>本篇文章是怀着赞许与尊敬从<a href="https://dev.to/lydiahallie" target="_blank" rel="noopener noreferrer">Lydia Hallie</a>的文章中翻译而来的，<a href="https://dev.to/lydiahallie/javascript-visualized-promises-async-await-5gke" target="_blank" rel="noopener noreferrer">原文</a>写的实在是太性感了</p></div><p>你是否有过这样的经历，跑一段JS代码，但它就是不按你预期地运行？看起来就像是一些函数被随机地，在不可预测的时间被执行了，或者执行被延迟了。那你可能正在与ES6引入的新特性打交道：<strong>Promise</strong> . 中文译名：期约</p><p>Promise是什么？为什么要用它？它到底是怎么工作的？如何使用它?</p><p>往下看之前最好先看看<a href="/translation/devto-jseventloop.html"><em>事件循环</em></a> 的原理. 如果你还没看过.</p><h2 id="介绍"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h2><p>在编写JavaScript时，我们经常不得不处理依赖于其他任务的任务！假设我们想要获取一张图像，对其进行压缩，应用过滤器，然后将其保存。</p><p>我们需要做的第一件事，就是获取我们想要编辑的图像。<em>getImage</em> 函数可以解决这个问题！只有在成功加载该图像之后，我们才能将该值传递给 <em>resizeImage</em> 函数。当图像成功调整大小时，我们希望在 <em>applyFilter</em> 函数中对图像应用过滤器。在压缩图像并添加筛选器后，我们希望保存图像并让用户知道一切工作正常！</p><p>最后，我们会得到这样的结果：</p><p><img src="/assets/PAA-1.6a595c51.png" alt="PAA-1"></p><p>虽然这么做也可以，但我们最终得到了许多嵌套的回调函数，它们依赖于前面的回调函数，这简直是回调地狱，这样的代码很难懂也很难维护。</p><p>幸运的是，现在我们有了Promise，让我们来看看什么是Promiss，以及它在这样的情况下可以如何帮助我们！</p><h2 id="promise语法"><a class="header-anchor" href="#promise语法" aria-hidden="true">#</a> Promise语法</h2><p>我们可以使用一个接受回调函数的 <em>Promise构造函数</em> 来创建 <em>Promise</em> :</p><p><img src="/assets/PAA-2.2000007a.gif" alt="PAA-2"></p><p>等等，这是返回了个什么玩意儿？</p><p><em><strong>Promise</strong></em> 是一个对象，包含着一个 <strong>status</strong>([[PromiseStatus]]) 属性和一个 <strong>value</strong>([[PromiseValue]])属性。从上面的动图中你可以看见 <em>[[PromiseStatus]]</em> 的值为 &quot;pending&quot;，<em>Promise</em> 的值为 <em>undefined</em> .</p><p>别担心--你不永远不必与此对象交互，甚至不能访问[[PromiseStatus]]和[[PromiseValue]]属性！但是，在使用Promises时，这些属性的值很重要。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>译者注：期约的状态是私有的，不能直接通过 JavaScript 检测到。这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。另外，期约的状态也不能被外部 JavaScript 代码修改。这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码</p></div><p><em>Promise</em> 的状态[[PromiseStatus]]有以下三种：</p><ul><li>⏳ <em>pending</em> : promise既没有被兑现(fulfilled)，也没有被拒绝(rejected) , promise依旧悬而未决</li><li>✅ <em>fulfilled</em> ：promise已经被兑现(fulfilled)，一切都很顺利，没有发生任何错误</li><li>❌ <em>rejected</em> : promise已经被拒绝(rejected), 什么事情出错了</li></ul><blockquote><p>译者举例子：想象你叫了一辆滴滴，把从平台接单到司机把你送到目的地当做一个Promise,就是你和平台立下一个期约，约定在那个时间段内，平台派车把你送到目的地。</p><p>在你下单后，直到你被送到目的地前，这个状态都一直是 <em>pending</em>， 因为你还没有到目的地(promise还没有被兑现)，你也没有&quot;到不了目的地&quot;(promise还没有出错)</p><p>然后接下来会出现两种情况：</p><ol><li><p>你被安全地送到了目的地，promise被兑现，状态改成fulfilled</p></li><li><p>司机接到电话，说他老婆突然要生孩子了，司机作为一个好男人，决定要去医院，不去接你了，取消了订单。</p><p>或者司机突然发现他没老婆，但是他开的是某度造的车，半路给你带到莆田系医院去了等等等等，总之就是出现问题了，那么promise的状态就成了rejected，因为promise没有被完成。</p></li></ol></blockquote><p>在上面的例子中，我们只是简单地传了一个回调函数 <code>() =&gt; {}</code> 给 <em>Promise</em> 构造器。然而，这个回调函数实际上接受两个参数：第一个参数常常被称作 <code>resolve</code> 或者 <code>res</code> , 是当 <em>Promise</em> 的状态应当改为 <em>fulfilled</em> 时触发。第二个参数常常被称作 <code>reject</code> 或者 <code>rej</code> , 是当 <em>Promise</em> 的状态应当改为 <em>reject</em> 时触发，表示有什么东西出错了</p><p><img src="/assets/PAA-3.b69afe1e.png" alt="PAA-3"></p><p>让我看看调用 <code>resolve</code> 或者<code>reject</code> 方法时会输出什么：</p><p><img src="/assets/PAA-4.fcb7f00c.gif" alt="PAA-4"></p><p>不错！我们终于知道如何摆脱 <em>pending</em> 状态和 <em>undefined</em> 值！如果我们调用了 <code>res</code> 函数，那么 <em>promise</em> 的状态就是 &quot;fulfilled&quot;，如果我们调用了<code>rej</code> 函数，那么 <em>promise</em> 的状态就是&quot;rejected&quot;。而<em>promise</em> 的值，既[[PromiseValue]]的值，就是我们传给 <code>res</code> 或者<code>rej</code>的值。</p><p>好了，现在我们对如何控制那个模糊的 <em>Promise</em> 对象有了更多的了解。但是它是用来做什么的呢？</p><p>在介绍部分中，我展示了一个示例，在该示例中，我们获取图像、压缩它、应用过滤器，并保存它！最终，这变成了一个疯狂嵌套回调的乱七八糟的局面。</p><p>幸运的是，<em>Promise</em> 可以帮助我们解决这个问题！首先，让我们重写整个代码块，以便每个函数返回一个 <em>Promise</em>。</p><p>如果图像已加载，并且一切正常，那就调用<code>res</code>来处理promise吧！否则，如果在加载文件时出现错误，那就调用<code>rej</code>来处理promise吧.<img src="/assets/PAA-5.a76b88f6.png" alt="PAA-5"></p><p>让我们看看当我们在终端中运行这段代码时会发生什么！</p><p><img src="/assets/PAA-6.6233244a.gif" alt="PAA-6"></p><p>棒！正如我们预期的那样，返回了一个promise，其中包含已解析数据的值。</p><p>然后呢？我们不关心整个Promise对象，我们只关心数据的值！幸运的是，有一些内置的方法可以获得promise的值。对于promise，我们可以附加3种方法：</p><ul><li><code>.then()</code>: 在promise执行<code>resolve</code>之后被执行</li><li><code>.catch()</code>: 在promise执行<code>reject</code>之后被执行</li><li><code>.finally()</code>: 无论promise执行<code>resolve</code>或者是<code>reject</code>，都会被执行</li></ul><p><img src="/assets/PAA-7.9264584f.png" alt="PAA-7"></p><p><code>.then</code>方法接受传递给<code>resolve</code>方法的值</p><p><img src="/assets/PAA-8.dd090a85.gif" alt="PAA-8"></p><p><code>.catch</code>方法接受传递给<code>reject</code>方法的值</p><p><img src="/assets/PAA-9.33654568.gif" alt="PAA-9"></p><p>终于，我们得到了在没有整个Promise对象的情况下由Promise生成的值！我们现在可以用这个值做任何我们想做的事情。</p><hr><p>仅供参考，当您知道promise将始终<code>resolve</code>或始终<code>reject</code>时，您可以使用要reject或resolve promise的值编写Promise.resolve或Promise.reject！（翻译不明白，太难翻译了，还是看图吧）</p><p><img src="/assets/PAA-10.3f78495f.png" alt="PAA-10"></p><p>接下来你会经常看到这种语法</p><hr><p>在<em>getImage</em>示例中，我们最终不得不嵌套多个回调才能运行它们。幸运的是，<code>.then</code> 处理程序可以帮助我们！</p><p><code>.then</code> 方法本身的返回值也是一个promise值(注意是返回值哦，传给 <em>.then</em> 的是promise 的value，不是promise)，这意味着我们可以链接任意多个<code>.then</code>：前一个<em>then</em>回调的结果将作为参数传递给下一个<em>then</em>回调！</p><p><img src="/assets/PAA-11.88e20a41.png" alt="PAA-11"></p><p>在<em>getImage</em>示例中，我们可以链接多个<em>then</em>回调，以便将处理后的图像传递给下一个函数！我们得到的不是许多嵌套的回调，而是一个干净的<em>then</em>链。</p><p><img src="/assets/PAA-12.d9425e7d.png" alt="PAA-12"></p><p>完美！这个写法可比之前的好多了</p><hr><h2 id="（宏）任务队列和微任务队列"><a class="header-anchor" href="#（宏）任务队列和微任务队列" aria-hidden="true">#</a> （宏）任务队列和微任务队列</h2><p>现在我们对如何创造 <em>promise</em> 以及如何从 <em>promise</em> 中提取值有了更多的了解。让我们再向脚本中添加一些代码，然后再次运行它：</p><p><img src="/assets/PAA-13.8f026eed.gif" alt="PAA-13"></p><p>等等，发生了什么！🤯</p><p>首先，“Start!” 被打印出来，这个没问题。然而第二个被打印出来的值居然是 &quot;End!&quot; ，而不是promise的resolve的值，&quot;Promise!&quot; 最后才被打印出来，发生了什么？</p><p>我们终于看到了 <em>promise</em> 的真正力量！虽然JavaScript是单线程的，但我们可以使用 <em>promise</em> 添加异步行为！</p><hr><p>等一下，我<a href="/translation/devto-jseventloop.html">事件循环</a>呢?难道我们不能使用浏览器原生的方法(如setTimeout)来创建某种异步行为吗？</p><p>当然可以！不过，在事件循环中，其实有两种类型的队列：<strong>（宏）任务队列</strong> 和 <strong>微任务队列</strong>，（宏）任务队列用于（宏）任务，微任务队列用于微任务。</p><p>那么什么是（宏）任务，什么又是微任务呢？常见的如下表所示，包括但不限于</p><table><thead><tr><th style="text-align:center;">种类</th><th style="text-align:center;">任务</th></tr></thead><tbody><tr><td style="text-align:center;">(宏）任务</td><td style="text-align:center;">setTimeout<code>|</code>setInterval<code>|</code>setImmediate</td></tr><tr><td style="text-align:center;">微任务</td><td style="text-align:center;">Promise callback<code>|</code>process.nextTick<code>|</code>queueMicrotask</td></tr></tbody></table><p>啊，我们在微任务列表中看到了Promise！当Promise调用其<code>then()</code>、<code>catch()</code>或<code>finally()</code>方法时，方法中的回调被添加到微任务队列中！这意味着<code>then()</code>、<code>catch()</code>或<code>finally()</code>方法中的回调不会立即执行，实质上是向我们的JavaScript代码添加了一些异步行为！</p><p>那么<code>then()</code>、<code>catch()</code>或<code>finally()</code>方法中的回调函数是什么时候执行的呢？事件循环为任务赋予不同的优先级：</p><ol><li>执行当前在调用堆栈中的所有函数。当它们返回值时，它们会从堆栈中弹出。</li><li>当调用堆栈为空时，所有排队的微任务将逐个弹出到调用堆栈上，并被执行！(微任务本身也可以返回新的微任务，有效地创建了一个无限的微任务循环)</li><li>如果调用堆栈和微任务队列都为空，事件循环就会检查(宏)任务队列上是否有剩余的任务。然后（宏）任务被弹出到调用堆栈上，执行，然后弹出！</li></ol><hr><p>让我们快速来看一个简单的例子：</p><ul><li><em>Task1</em> : 一个立即添加到调用堆栈中的函数。在我们的代码中可以立即调用它。</li><li><em>Task2, Task3, Task4</em> ：微任务们。例如，一个promise的<code>then</code>回调函数，或者使用 <em>queneMicrotask</em> 添加的任务</li><li><em>Task5， Task6</em> : 一个(宏)任务队列, 例如，<em>setTimeout</em> 和 <em>setImmediate</em> 的回调函数</li></ul><p><img src="/assets/PAA-15.9466d8aa.gif" alt="PAA-15"></p><p>首先，<em>Task1</em>返回一个值，并从调用堆栈中弹出。然后，引擎检查微任务队列中排队的任务。一旦所有任务都被放入调用堆栈并最终弹出，引擎就会检查(宏)任务队列中的任务，这些任务被推到调用堆栈上，并在它们返回值时被弹出。</p><p>也就是说，事件执行的优先级顺序为：<strong>同步函数 &gt; 微任务(不进入Web API) &gt; (宏)任务</strong></p><p>现在我们用一些真正的代码来使用它！</p><p><img src="/assets/PAA-16.f184c847.png" alt="PAA-16"></p><p>在这段代码中，我们有宏任务<em>setTimeout</em>和微任务Promise *then()*回调。一旦引擎到达setTimeout函数行。让我们一步一步地运行这段代码，看看记录了什么！</p><p>在第一行，引擎遇到console.log()方法。它被添加到调用堆栈，之后打印出值*start！*到控制台。该方法从调用堆栈中弹出，引擎继续。</p><p><img src="/assets/PAA-17.c21ce906.gif" alt="PAA-17"></p><p>接着引擎遇到<em>setTimeout</em>方法，该方法被推到调用堆栈。<em>setTimeout</em>方法是浏览器原生的：它的回调函数<code>()=&gt;console.log(‘in timeout’)</code>将被添加到Web API(此时<em>setTimeout</em>已经返回了值，被弹出堆栈)，直到计时器结束。尽管我们为计时器提供了值0，但是回调仍然首先被推送到Web API，然后被添加到(宏)任务队列：<em>setTimeout</em>是一个宏任务！</p><p><img src="/assets/PAA-18.16de7c62.gif" alt="PAA-18"></p><p>继续，引擎遇到*Promise.resolve()*方法。*Promise.resolve()*方法被添加到调用堆栈中，after which is resolves with the value <code>Promise!</code>. Its <code>then</code> callback function gets added to the <strong>microtask queue</strong>.（翻译不来，自己理解）</p><p><img src="/assets/PAA-19.ca019b19.gif" alt="PAA-19"></p><p>往下，引擎遇到console.log()方法。它会立即添加到调用堆栈中，然后打印出值*End！*到控制台，从调用堆栈中弹出，引擎继续。</p><p><img src="/assets/PAA-20.f3e1fe88.gif" alt="PAA-20"></p><p>紧接着，引擎发现调用堆栈现在为空。由于调用堆栈为空，它将检查微任务队列中是否有排队的任务！是的，确实有，promise的 <em>then</em> 回调函数已经迫不及待了！它被推入进调用堆栈中，然后输出Promise的resolved的值：在本例中是字符串<code>Promise！</code></p><p><img src="/assets/PAA-21.e56ca9bc.gif" alt="PAA-21"></p><p>引擎发现调用堆栈为空，因此它将再次检查微任务队列，以查看是否还有任务在排队。不，微任务队列都是空的。</p><p>现在是检查(宏)任务队列的时候了：<em>setTimeout</em>回调仍在那里等待！<em>setTimeout</em>回调被推入进调用堆栈。回调函数返回<em>console.log</em>方法，该方法记录字符串<code>“In Timeout！”</code>。<em>setTimeout</em>回调从调用堆栈中弹出。</p><p><img src="/assets/PAA-22.0bbbd787.gif" alt="PAA-22"></p><p>终于完成了！看起来也就那么亿点点复杂嘛.</p><hr><h2 id="async-await"><a class="header-anchor" href="#async-await" aria-hidden="true">#</a> Async / Await</h2><p>ES7引入了一种新的方式来在JavaScript中添加异步行为，并使得使用 <em>Promise</em> 变得更容易！通过引入<em>async</em>和<em>await</em>关键字，我们可以创建隐式返回承诺的异步函数。但是我们怎么能做到这一点呢？。</p><p>在前面，我们看到可以使用<em>Promise</em>对象显式创建承诺，无论是通过键入<code>new Promise(()=&gt;{})</code>、<em>Promise.resolve</em>还是<em>Promise.reject</em>。</p><p>我们现在可以创建隐式返回对象的异步函数，而不是显式使用<em>Promise</em>对象！这意味着我们不再需要自己编写任何<em>Promise</em>对象。</p><p><img src="/assets/PAA-23.a1c05a9f.png" alt="PAA-23"></p><p>尽管 <em>async</em> 函数隐式返回 <em>promises</em> 的事实不可置否，但在使用<em>await</em>关键字时，才可以看到<em>async</em>函数的真正威力！使用<em>await</em>关键字，我们可以挂起异步函数，同时等待被 <em>await</em> 的值返回已解析的承诺。如果我们想要获得这个已解析承诺的值，就像我们之前对*then()*回调所做的那样，我们可以将变量赋给等待的承诺值！</p><p>所以，我们可以暂停异步功能？好的，很好，但是..这到底是什么意思？</p><p>让我们看看当我们运行以下代码块时会发生什么：</p><p><img src="/assets/PAA-24.42188dbe.gif" alt="PAA-24"></p><p>发生了什么？</p><p><img src="/assets/PAA-25.ab7dc59e.gif" alt="PAA-25"></p><p>首先，引擎遇到一个<code>console.log</code>。它被推入到调用堆栈上，打印出 <em>Before function</em>。</p><p><img src="/assets/PAA-26.f6562e94.gif" alt="PAA-26"></p><p>然后，我们调用异步函数<code>myFunc()</code>，然后运行<em>myFunc</em>的函数体。在函数体的第一行，我们调用另一个<code>console.log</code>，打印出<code>In function!</code></p><hr><p><img src="/assets/PAA-27.f6e2ad0c.gif" alt="PAA-27"></p><p>函数体继续被执行，这将我们带到第二行。最后，我们看到一个<em>await</em>关键字！。</p><p>在这里发生的第一件事是执行<em>await</em>后的值：在这里是 <em>one</em> 函数。它被推入到调用堆栈上，并最终返回一个已解析的承诺。一旦承诺被解析并且 <em>one</em> 函数返回了值，引擎就会遇到<em>await</em>关键字。<strong>注意是先执行紧跟在await后的表达式然后再挂起async函数</strong>。</p><p>当遇到<em>await</em>关键字时，<em>async</em>函数被挂起。函数体的执行暂停，<em>async</em>函数的其余部分在微任务中运行，而不是在常规任务中运行！</p><hr><p><img src="/assets/PAA-28.01e9aed0.gif" alt="PAA-27"></p><p>现在<em>async</em>函数<em>myFunc</em>由于遇到<em>await</em>关键字而挂起，引擎跳出异步函数并继续在调用异步函数的执行上下文中执行代码：在本例中是全局执行上下文！</p><hr><p><img src="/assets/PAA-29.845c7ad7.gif" alt="PAA-29"></p><p>最后，已经没有任务需要在在全局执行上下文中运行！事件循环检查是否有任何微任务在排队：确实有！异步<em>myFunc</em>函数在解析<em>one</em>的值后排队。<em>myFunc</em>推入调用堆栈，并在之前停止的地方继续运行。</p><p>变量<em>res</em>最终获得它的值，即promise的<code>resolve</code>的值！我们调用<code>console.log</code>打印出<em>res</em>的值：字符串<code>one!</code>并从调用堆栈中弹出！。</p><p>终于，一切都完成了！你有没有注意到，与<em>promise</em>相比，<em>async</em>功能有何不同？<em>await</em>关键字挂起异步函数，而如果我们当时使用了Promise的<code>.then()</code>，那么Promise将继续执行！</p><blockquote><p>翻译到后面感觉翻译地乱七八糟的。阅读原文移步<a href="https://dev.to/lydiahallie/javascript-visualized-promises-async-await-5gke" target="_blank" rel="noopener noreferrer">这里</a></p></blockquote></div></div><footer class="page-footer" data-v-d36a7fda data-v-5a019cc9><div class="edit" data-v-5a019cc9><div class="edit-link" data-v-5a019cc9 data-v-fb0131f2><!----></div></div><div class="updated" data-v-5a019cc9><!----></div></footer><div class="next-and-prev-link" data-v-d36a7fda data-v-6683615c><div class="container" data-v-6683615c><div class="prev" data-v-6683615c><a class="link" href="/translation/devto-jseventloop" data-v-6683615c><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-6683615c><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-6683615c>JavaScript中的事件循环</span></a></div><div class="next" data-v-6683615c><!----></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"typescript.md\":\"b90fc219\",\"export-import.md\":\"250df970\",\"index.md\":\"43eaad03\",\"society--kim-jong-un.md\":\"d2190b53\",\"vitepress-blog-depoly.md\":\"04da652e\",\"vitepress-blog-setup.md\":\"f8230c1e\",\"jsnote_1.md\":\"0c892726\",\"jsnote_2.md\":\"5b3e21cf\",\"jsnote_3.md\":\"423ef526\",\"translation_devto-jseventloop.md\":\"16a5493e\",\"translation_devto-promises-async-await.md\":\"b30fd95a\"}")</script>
    <script type="module" async src="/assets/app.2a123ea2.js"></script>
  </body>
</html>